# Руководство для запуска контенейра с systemd

## Немного от теории работы systemd в Докере

Модель Docker предполагает, что лучше запускать одну службу в контейнере. Если вы хотите создать приложение, для которого требуется служба Apache и база данных MariaDB, вы должны создать два разных контейнера. Таким образом, docker не нуждается в systemd, который является инструментом для мониторинга нескольких служб. Таким образом, он **отключен по умолчанию** и для повышения безопасности и изоляции контейнера и его службы.

### Включить systemd внутри Docker  

Обычная ошибка при использовании systemctl
`System has not been booted with systemd as init system (PID 1). Can’t operate.`
(Система не была загружена с использованием systemd в качестве системы инициализации (PID 1). Не могу работать.)

1. Здесь процесс с PID 1 - это bash. Вам должно быть интересно, что означает этот PID 1? Процесс с PID 1 действует как точка входа в контейнер или просто вы можете сказать, что это первый процесс, вызываемый ядром. В современных системах PID 1 активно зарезервирован для процесса инициализации, но не в докере. Bash имеет PID , но для работы systemd необходимо запускать как PID 1, но это еще не все.

2. Systemd требует возможности CAP_SYS_ADMIN, но Docker отбрасывает эту возможность в непривилегированных контейнерах, чтобы повысить безопасность. Это означает, что на данный момент вы должны запускать systemd в привилегированном контейнере, поскольку привилегированные контейнеры не теряют никаких возможностей, но последние исправления позволяют пользователям добавлять возможности в контейнер докеров. Мы можем просто добавить возможность CAP_SYS_ADMIN без запуска контейнера в привилегированном режиме.

Но контейнер docker все равно не сработает, потому что systemd настаивает на просмотре файловой системы cgroup внутри контейнера. Мы можем добавить файловую систему cgroup в контейнер, используя Volume mount `–v /sys/fs/cgroup:/sys/fs/cgroup:ro` который позволяет systemd просматривать контрольную группу, но только в режиме только для чтения. Если ваша хост-система не имеет должным образом настроенной контрольной группы, вы можете столкнуться с проблемой.

Теперь у нас есть все ингредиенты для включения systemd внутри докера, мы можем сделать это одной командой.

```bash
docker run -d -v /sys/fs/cgroup/:/sys/fs/cgroup:ro --cap-add SYS_ADMIN -p 8089:80 -v /webpages/:/var/www/html --name systemd_websrv centos /sbin/init
```

(запуск демона как фоновый процесс с указанием привилегий)

Но, включив systemd, systemd также включает дополнительные службы внутри докера, как вы можете видеть. Чтобы остановить это, мы можем создать Dockerfile и удалить ссылки на файлы модулей из  /lib/systemd/system/*wants/ и /etc/systemd/system/*wants/ каталоги в контейнере докеров на основе systemd. Удаление этих ссылок приведет к созданию образа контейнера systemd, который будет запускать только systemd и journald.

Кроме `--cap-add SYS_ADMIN` существует `--privileged`, что значит - предоставить расширенные привилегии этому контейнеру (Full container capabilities). В состав эти привилегий также входит SYS_ADMIN, но если есть возможность не использовать `--privileged`, то указывать только необходимые привилегии.

Флаг --privileged предоставляет все возможности контейнера, а также снимает все ограничения, налагаемые контроллером cgroup устройства. Другими словами, контейнер может делать почти все, что может делать хост. Этот флаг существует для особых случаев использования, таких как запуск Docker внутри Docker.

### Ключ tmpfs

Что касаетcя `--tmpfs /tmp --tmpfs /run --tmpfs /run/lock`

Краткий ответ: они хранят временные системные файлы, включая блокировки устройств и сегменты памяти, совместно используемые разными процессами. Не волнуйтесь, они обычно используют часть своего "размера", показанного df

1. /run - это, как правило, временная файловая система (tmpfs), находящаяся в ОЗУ (также известная как «ramdisk»); он предназначен для хранения «временных» файлов системы или состояний, которые могут быть критическими, но не требуют сохранения при перезагрузке. /run на самом деле является довольно новым нововведением и был добавлен пару лет назад для замены нескольких созданных ранее tmpfs (включая /var /lock и /dev /shm) на один унифицированный корневой tmpfs. Основными местами /заменами пробега являются:
   1. /run на самом деле является довольно новым нововведением и был добавлен пару лет назад для замены нескольких созданных ранее tmpfs (включая /var /Lock и /dev /shm) на один унифицированный корневой tmpfs.

2. /run /lock (ранее /var /lock) содержит файлы блокировки, то есть файлы, указывающие на то, что используется совместно используемое устройство или другой системный ресурс, и содержащие идентификатор процесса (PID), который его использует; это позволяет другим процессам правильно координировать доступ к общему устройству

3. /run /shm (ранее /dev /shm) - это временная разделяемая память с возможностью записи для всех. Строго говоря, он предназначен для хранения программ, использующих POSIX Shared Memory API. Это облегчает так называемое межпроцессное взаимодействие (IPC), когда различные процессы могут совместно использовать и взаимодействовать через общую область памяти, которая в данном случае обычно представляет собой обычный файл, хранящийся на «виртуальном диске». Конечно, его можно использовать и в других творческих целях.

4. Не беспокойтесь о размере: что важно, многие люди, запускающие df -h и зная, что /run поддерживается оперативной памятью, шокированы тем, что их драгоценная память «тратится» этими загадочными папками. Точно так же, как Linux съел мой миф о RAM, это убеждение неверно.

   1. Указанный размер - это только максимально допустимый размер.
   2. По умолчанию это 50% физической ОЗУ.
   3. Фактически используется только то количество, которое показано в столбце "Используется", что на приведенном выше снимке экрана составляет менее 1 мегабайта.
   4. Вы можете использовать команду ipcs -m, чтобы убедиться, что фактические используемые сегменты разделяемой памяти соответствуют сводке df, а также посмотреть, какие PID их используют.
   5. Как и ваша обычная оперативная память, /run также в конечном итоге поддерживается вашим свопом, поэтому, если вы используете /run /shm для "более быстрого" времени компиляции, имейте это в виду

## Для инициализации systemd необходимо запустить контейнер в фоновом режиме со следующими ключами

1. Обязательные ключи для работы systemd

    * Для особых случаев...

        `--privileged -v /sys/fs/cgroup:/sys/fs/cgroup:ro`

    * Для rosa73cobalt, alteros7, centos78

        `-v /sys/fs/cgroup:/sys/fs/cgroup:ro --cap-add SYS_ADMIN`

    * Для ubuntu1804, rhel82 ,rhel78, redos, centos82, astralinux212
  
        `--tmpfs /tmp --tmpfs /run --tmpfs /run/lock -v /sys/fs/cgroup:/sys/fs/cgroup:ro`

2. Рекомендуемые ключи (для запуска в фоновом режиме и удаления контейнера по завершению его работы): `-d --rm`  
3. Указание в конце имени образа с тегом обязательно!
4. Общая команда запуска в фононом режиме контейнера (на примере Centos78):

    ```bash
    docker run -d --rm \
    --privileged -v /sys/fs/cgroup:/sys/fs/cgroup:ro \
    --name name
    ```

## Для входа в контейнер и выполенения каких-либо операций внутри

### Варианты

1. Войти в контейнер (на примере Centos78):

    ```bash
    docker exec -it name bash
    ```

2. Запустить что-то внутри (на примере Centos78)

    ```bash
    docker exec name bash -c "ls -la"
    ```

## Rootless-режим работы докера от имени не-root-пользователя

Режим без root позволяет запускать демон и контейнеры Docker от имени пользователя без полномочий root, чтобы уменьшить потенциальные уязвимости в демоне и среде выполнения контейнера.

Режим без root не требует прав суперпользователя даже во время установки демона Docker, если выполняются предварительные условия.

Режим без рута был представлен в Docker Engine v19.03 в качестве экспериментальной функции. Безрунтный режим вышел из экспериментального в Docker Engine v20.10.

**Внимание!** Если общесистемный демон Docker уже запущен, рассмотрите возможность его отключения
`sudo systemctl disable --now docker.service docker.socket`

1. Если вы установили Docker 20.10 или позднее с RPM/DEB пакетами, вы должны иметь `dockerd-rootless-setuptool.sh` в `/usr/bin`. Если `dockerd-rootless-setuptool.sh` не представлена, у вас есть возможность устноавить его с `docker-ce-rootless-extra` пакетом вручную (`sudo apt-get install -y docker-ce-rootless-extras`)

    ```bash
    dockerd-rootless-setuptool.sh install
    ```

2. Использование
   * Юнит-файл systemd устанавливается как `~/.config/systemd/user/docker.service`
   * Используйте systemctl --user для управления жизненым циклом демона:
      * `systemctl --user start docker`
   *. Чтобы запустить демон при запуске системы, включите службу systemd:
      * `systemctl --user enable docker`
      * `sudo loginctl enable-linger $(whoami)`

    **Внимание**: Запуск Docker без рута в качестве общесистемной службы (/etc/systemd/system/docker.service) не поддерживается, даже с `User=` директивой.

3. Проверка контекста запуска докера:
         `docker context use rootless`

4. Удаление rootless-режима:
   1. `cd /usr/bin && dockerd-rootless-setuptool.sh uninstall`
   2. `rootlesskit rm -rf ~/.local/share/docker` - для удаления каталога данных о docker
   3. Чтобы удалить двоичные файлы, удалите `docker-ce-rootless-extras package` пакет, если вы установили Docker с менеджерами пакетов. Если вы [установили Docker с](https://get.docker.com/rootless) (установка не через пакеты), удалите двоичные файлы из `~/bin`:

        ```dotnetcli
        cd ~/bin
        rm -f containerd containerd-shim containerd-shim-runc-v2 ctr docker docker-init docker-proxy dockerd dockerd-rootless-setuptool.sh dockerd-rootless.sh rootlesskit rootlesskit-docker-proxy runc vpnkit

        ```

5. Подробнее о технологии: [Перейти](https://docs.docker.com/engine/security/rootless/)

## Дополнительно, ссылки на источники

* [Rootless-режим](https://docs.docker.com/engine/security/rootless/)
* [Статья на Medium](https://medium.com/swlh/docker-and-systemd-381dfd7e4628)
* [Примеры работающего Systemd](https://github.com/j8r/dockerfiles/tree/master/systemd/ubuntu)
